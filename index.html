<!DOCTYPE html>
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Submit a Doodle!!!</title>
    <style>
        body {
            background-color: #feb1cb;
            font-family: sans-serif;
            text-align: center;
            padding: 2rem;
        }

        canvas {
            border: 1px solid black;
            background: white;
            width: 400px;
            height: 300px;
            touch-action: none;
            margin: 0 auto;
        }

        #tools {
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            gap: 10px;
            align-items: center;
        }

        .tool-icons {
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .button {
            margin: 5px;
            padding: 10px;
            cursor: pointer;
        }

        #eraser, #brush, #eyedropper, #bucket {
            width: 32px;
            height: 32px;
            vertical-align: middle;
            cursor: pointer;
        }

        @media (max-width: 600px) {
            body {
                padding: 1rem;
            }

            #tools {
                flex-direction: column;
                align-items: center;
                gap: 0.5rem;
            }

            .button, #brushSize, #colorPicker {
                width: 100%;
                max-width: 300px;
            }

            label {
                display: block;
                margin-top: 0.5rem;
            }

            #brushSize {
                margin: 0.25rem 0;
            }

            .tool-icons {
                gap: 1rem;
            }

            img {
                margin: 0 5px;
            }
        }
        #layerMenu {
            position: absolute;
            top: 55px;
            left: 20px;
            width: 200px;
            background: #fff;
            border: 1px solid #aaa;
            border-radius: 8px;
            box-shadow: 2px 2px 10px rgba(0,0,0,0.2);
            padding: 10px;
            display: none; /* Hidden by default */
            z-index: 1000;
            text-align: left;
        }

        #toggleLayerMenu {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 1100;
            background: #ff89a4;
            color: white;
            border: none;
            border-radius: 4px;
            padding: 6px 12px;
            cursor: pointer;
            font-weight: bold;
        }

        #layerContent {
            margin-top: 10px; /* Increase this value for more space */
        }

        .layer-item.selected {
            border: 2px solid #ff4d88;
            border-radius: 6px;
            padding: 4px;
            background: #ffe5ed;
        }

        .layer-item {
            cursor: pointer;
            transition: background 0.2s ease;
        }

            .layer-item:hover {
                background: #fce4ec;
            }
        .layer-label {
            display: block;
            width: 100%;
            box-sizing: border-box;
            padding: 2px 4px;
            border-radius: 4px;
            cursor: pointer;
            user-select: none;
            transition: background-color 0.2s ease;
            background-color: transparent;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }


            .layer-label:hover {
                background-color: #ff9cb1; /* Pink only around text */
            }

        .layer-placeholder {
            height: 4px;
            background-color: #ff4d88;
            margin: 4px 0;
            border-radius: 2px;
        }


        .layer-arrows {
            display: flex;
            flex-direction: column;
            gap: 2px;
            margin-left: auto; /* Push to right in the grid */
        }

            .layer-arrows button {
                all: unset; /* Remove all default button styles */
                cursor: pointer;
                font-size: 14px;
                line-height: 1;
                text-align: center;
                padding: 2px 4px;
                border-radius: 4px;
                transition: background 0.15s ease;
            }

                .layer-arrows button:hover {
                    background: #ffe0e8;
                }

        #opacitySlider {
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            cursor: pointer;
        }

            #opacitySlider:disabled {
                opacity: 0.4;
                cursor: not-allowed;
            }

            /* Track (the line) */
            #opacitySlider::-webkit-slider-runnable-track {
                height: 4px;
                background: #ccc;
                border-radius: 10px;
            }

            #opacitySlider::-moz-range-track {
                height: 4px;
                background: #ccc;
                border-radius: 10px;
            }

            /* Thumb (the circle) */
            #opacitySlider::-webkit-slider-thumb {
                -webkit-appearance: none;
                height: 14px;
                width: 14px;
                background: white;
                border: 2px solid #ff4d88;
                border-radius: 50%;
                margin-top: -5px; /* to center over track */
            }

            #opacitySlider::-moz-range-thumb {
                height: 14px;
                width: 14px;
                background: white;
                border: 2px solid #ff4d88;
                border-radius: 50%;
            }

        .layer-item span[title="Alpha Lock"]:hover {
            background: #ffe0e8;
            border-radius: 4px;
            padding: 2px;
        }

        .layer-item img[alt="Alpha Lock Toggle"]:hover {
            background: #ffe0e8;
            border-radius: 4px;
        }

        #downloadBtn {
            position: absolute;
            top: 12px;
            right: 20px;
            z-index: 1100;
            background: #ff89a4;
            color: white;
            font-size: 18px;
            border: none;
            border-radius: 6px;
            padding: 6px 10px;
            cursor: pointer;
            box-shadow: 1px 1px 5px rgba(0,0,0,0.2);
            transition: background 0.2s ease;
        }

            #downloadBtn:hover {
                background: #ff5e88;
            }



    </style>
</head>
<body>
    <h1>Submit a Doodle!!!</h1>
    <div id="alphaTooltip" style="position: fixed; pointer-events: none; background: #222; color: white; font-size: 12px; padding: 4px 6px; border-radius: 4px; display: none; z-index: 9999;">Alpha Lock</div>
    <button id="toggleLayerMenu">‚ò∞ Layers</button>
    <div id="layerMenu">
        <div style="display: flex; gap: 6px; align-items: center; margin-bottom: 10px;">
            <button id="addLayer" title="Add new layer">‚ûï</button>
            <button id="deleteLayer" title="Delete selected layer">üóëÔ∏è</button>


            <div style="display: flex; flex-direction: column; align-items: center; gap: 2px;">
                <span style="font-size: 12px; color: #444; margin-bottom: -2px;">Opacity</span>
                <div style="display: flex; align-items: center; gap: 6px;">
                    <input id="opacitySlider"
                           type="range"
                           min="0"
                           max="1"
                           step="0.01"
                           value="1"
                           title="Opacity"
                           style="width: 80px; height: 4px; accent-color: #ff4d88; border-radius: 10px;" />
                    <span id="opacityValue" style="font-size: 12px; color: #444;">100%</span>
                </div>
            </div>

        </div>


        <div id="layerContent">
            <p>Background Layer</p>
        </div>
    </div>

    <button id="downloadBtn" title="Download your doodle üíæ">üíæ</button>
    <canvas id="canvas" width="400" height="300"></canvas><br />

    <div id="tools">
        <button class="button" id="undo">Undo</button>
        <button class="button" id="redo">Redo</button>



        <label for="brushSize">Brush Size:</label>
        <input type="range" id="brushSize" min="1" max="10" value="2" />
        <span id="sizeLabel">2</span><br />

        <label for="colorPicker">Brush Color:</label>
        <input type="color" id="colorPicker" value="#000000" />

        <div class="tool-icons">
            <img id="brush" src="brush.png" alt="Brush Tool" title="Brush Tool" />
            <img id="eraser" src="eraser.png" alt="Eraser Tool" title="Eraser Tool" />
            <img id="eyedropper" src="eyedropper.png" alt="Eyedropper Tool" title="Eyedropper Tool" />
            <img id="bucket" src="bucket.png" alt="Bucket Tool" title="Bucket Tool" />
            <label style="font-size: 12px; display: flex; align-items: center; gap: 4px;">
                <input type="checkbox" id="contiguousToggle" checked />
                Contiguous
            </label>

        </div>
    </div>

    <button id="submit">Submit</button>

    <script>
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const undoButton = document.getElementById("undo");
        const redoButton = document.getElementById("redo");
        const brushSizeInput = document.getElementById("brushSize");
        const opacitySlider = document.getElementById("opacitySlider");
        const opacityValue = document.getElementById("opacityValue");
        const sizeLabel = document.getElementById("sizeLabel");
        const colorPicker = document.getElementById("colorPicker");
        const eraserIcon = document.getElementById("eraser");
        const contiguousToggle = document.getElementById("contiguousToggle");
        const brushIcon = document.getElementById("brush");
        const eyedropperIcon = document.getElementById("eyedropper");
        const bucketIcon = document.getElementById("bucket");
        const submitButton = document.getElementById("submit");
        const toggleLayerMenu = document.getElementById("toggleLayerMenu");
        const layerMenu = document.getElementById("layerMenu");

        // Initialize layers array with a background layer
        let activeLayerIndex = 0;
        let dragSrcIndex = null;
        let dragOverIndex = null;

        let layers = [
            {
                name: 'Background',
                canvas: document.createElement('canvas'),
                ctx: null,
                visible: true,
                undoStack: [],
                redoStack: [],
                opacity: 1,
                alphaLock: false
            }
        ];





        // Set canvas dimensions for the background layer
        layers[0].canvas.width = canvas.width;
        layers[0].canvas.height = canvas.height;
        layers[0].ctx = layers[0].canvas.getContext('2d');
        setActiveLayer(0);        // Use the background as the active layer
        updateLayerMenu();        // Show the background layer in the UI




        document.getElementById("addLayer").addEventListener("click", addNewDrawingLayer);
        document.getElementById("deleteLayer").addEventListener("click", () => {
            if (activeLayerIndex === 0) {
                alert("You can't delete the background layer!");
                return;
            }
            deleteLayer(activeLayerIndex);
        });


        // Function to toggle visibility of layers
        function toggleLayerVisibility(index) {
            layers[index].visible = !layers[index].visible;
            renderAllLayers();
            updateLayerMenu();
        }


        function setActiveLayer(index) {
            activeLayerIndex = index;
            renderAllLayers();
            updateLayerMenu();

            if (index === 0) {
                opacitySlider.disabled = true;
                opacitySlider.value = 1;
                opacityValue.textContent = "100%";
            } else {
                opacitySlider.disabled = false;
                opacitySlider.value = layers[index].opacity;
                opacityValue.textContent = Math.round(layers[index].opacity * 100) + "%";
            }

        }

        function moveLayer(fromIndex, toIndex) {
            if (fromIndex === 0 || toIndex === 0) return;
            if (toIndex < 0 || toIndex >= layers.length || fromIndex === toIndex) return;

            const layer = layers.splice(fromIndex, 1)[0];
            layers.splice(toIndex, 0, layer);

            // Adjust active layer index if necessary
            if (activeLayerIndex === fromIndex) {
                activeLayerIndex = toIndex;
            } else if (activeLayerIndex > fromIndex && activeLayerIndex <= toIndex) {
                activeLayerIndex -= 1;
            } else if (activeLayerIndex < fromIndex && activeLayerIndex >= toIndex) {
                activeLayerIndex += 1;
            }

            renderAllLayers();
            updateLayerMenu();
        }

        function deleteLayer(index) {
            if (index === 0) return; // Don't delete background!

            layers.splice(index, 1); // Remove the layer

            // Adjust active layer index if needed
            if (activeLayerIndex >= index) {
                activeLayerIndex = Math.max(0, activeLayerIndex - 1);
            }

            updateLayerMenu();     // Refresh UI
            renderAllLayers();     // Redraw canvas
        }



        function addNewDrawingLayer() {
            const newLayer = {
                name: `Layer ${layers.length - 1}`,
                canvas: document.createElement('canvas'),
                ctx: null,
                visible: true,
                undoStack: [],
                redoStack: [],
                opacity: 1,
                alphaLock: false
            };

            newLayer.canvas.width = canvas.width;
            newLayer.canvas.height = canvas.height;
            newLayer.ctx = newLayer.canvas.getContext('2d');

            const insertIndex = activeLayerIndex + 1;

            layers.splice(insertIndex, 0, newLayer); // üëà Insert ABOVE the active one
            setActiveLayer(insertIndex);             // üëà Make the new one active
            updateLayerMenu();
        }




        // Function to update the layer menu dynamically
        function updateLayerMenu() {
            const layerContent = document.getElementById("layerContent");
            layerContent.innerHTML = ''; // Clear previous layers

            // üîÅ Loop in REVERSE so newest layers appear first (on top)
            [...layers].reverse().forEach((layer, visualIndex) => {
                const actualIndex = layers.length - 1 - visualIndex;

                const layerDiv = document.createElement('div');
                layerDiv.classList.add('layer-item');
                layerDiv.style.display = "grid";
                layerDiv.style.gridTemplateColumns = "auto 1fr auto";
                layerDiv.style.alignItems = "center";
                layerDiv.style.columnGap = "6px";

                // Enable dragging
                layerDiv.setAttribute("draggable", actualIndex !== 0);


                layerDiv.addEventListener("dragstart", (e) => {
                    dragSrcIndex = actualIndex;
                    e.dataTransfer.effectAllowed = "move";
                });

                layerDiv.addEventListener("dragover", (e) => {
                    e.preventDefault(); // Allow drop
                    dragOverIndex = actualIndex;

                    // Add placeholder if it doesn't exist
                    const existing = document.querySelector(".layer-placeholder");
                    if (!existing) {
                        const placeholder = document.createElement("div");
                        placeholder.className = "layer-placeholder";
                        layerDiv.parentNode.insertBefore(placeholder, layerDiv.nextSibling);
                    }
                });

                layerDiv.addEventListener("dragleave", () => {
                    const placeholder = document.querySelector(".layer-placeholder");
                    if (placeholder) placeholder.remove();
                });

                layerDiv.addEventListener("drop", (e) => {
                    e.preventDefault();
                    const placeholder = document.querySelector(".layer-placeholder");
                    if (placeholder) placeholder.remove();

                    if (
                        dragSrcIndex !== null &&
                        dragOverIndex !== null &&
                        dragSrcIndex !== dragOverIndex
                    ) {
                        moveLayer(dragSrcIndex, dragOverIndex);
                    }

                    dragSrcIndex = null;
                    dragOverIndex = null;
                });

                layerDiv.addEventListener("dragend", () => {
                    const placeholder = document.querySelector(".layer-placeholder");
                    if (placeholder) placeholder.remove();
                });

                if (actualIndex === activeLayerIndex) {
                    layerDiv.classList.add('selected');
                }

                // üß± Grid layout
                layerDiv.style.display = 'grid';
                layerDiv.style.gridTemplateColumns = "auto auto 1fr auto";
                layerDiv.style.alignItems = 'center';
                layerDiv.style.columnGap = '6px';
                layerDiv.style.marginBottom = '6px';

                // üñº Thumbnail
                const thumb = document.createElement('canvas');
                const thumbWidth = 32;
                const thumbHeight = 24;
                thumb.width = thumbHeight;
                thumb.height = thumbHeight;

                thumb.style.width = `${thumbWidth}px`;
                thumb.style.height = `${thumbHeight}px`;
                thumb.style.border = '1px solid #aaa';
                thumb.style.background = '#fff';
                thumb.style.imageRendering = 'pixelated';
                thumb.style.flexShrink = '0';

                const thumbCtx = thumb.getContext("2d");
                thumbCtx.imageSmoothingEnabled = false;
                thumbCtx.clearRect(0, 0, thumb.width, thumb.height);
                const preview = document.createElement('canvas');
                preview.width = thumb.width;
                preview.height = thumb.height;
                const previewCtx = preview.getContext('2d');
                previewCtx.imageSmoothingEnabled = true;
                previewCtx.drawImage(layer.canvas, 0, 0, preview.width, preview.height);

                // üëÅÔ∏è Visibility toggle using emoji
                const visibilityToggle = document.createElement('span');
                visibilityToggle.textContent = layer.visible ? "üëÅÔ∏è" : "üö´";
                visibilityToggle.title = layer.visible ? "Visible" : "Hidden";
                visibilityToggle.style.cursor = "pointer";
                visibilityToggle.style.fontSize = "14px";
                visibilityToggle.style.userSelect = "none";
                visibilityToggle.style.flexShrink = "0";

                visibilityToggle.addEventListener('click', (e) => {
                    e.stopPropagation();
                    toggleLayerVisibility(actualIndex);
                    visibilityToggle.textContent = layers[actualIndex].visible ? "üëÅÔ∏è" : "üö´";
                    visibilityToggle.title = layers[actualIndex].visible ? "Visible" : "Hidden";
                });

                // üîí Alpha Lock emoji toggle
                const alphaLockToggle = document.createElement("img");
                alphaLockToggle.src = layer.alphaLock ? "lock.png" : "unlock.png";
                alphaLockToggle.alt = "Alpha Lock Toggle";
                alphaLockToggle.style.width = "18px";
                alphaLockToggle.style.height = "18px";
                alphaLockToggle.style.cursor = "pointer";
                alphaLockToggle.style.flexShrink = "0";
                if (actualIndex === 0) {
                    alphaLockToggle.style.opacity = "0.4";
                    alphaLockToggle.style.pointerEvents = "none";
                    alphaLockToggle.title = "Alpha Lock disabled on background layer";
                } else {

                }


                // üß± Stack visibility + alpha lock vertically
                const toggleWrapper = document.createElement("div");
                toggleWrapper.style.display = "flex";
                toggleWrapper.style.flexDirection = "column";
                toggleWrapper.style.alignItems = "center";
                toggleWrapper.style.gap = "4px";
                toggleWrapper.style.flexShrink = "0";
                toggleWrapper.appendChild(visibilityToggle);
                toggleWrapper.appendChild(alphaLockToggle);


                // Tooltip tracking
                const tooltip = document.getElementById("alphaTooltip");

                alphaLockToggle.addEventListener("mouseenter", () => {
                    tooltip.style.display = "block";
                });
                alphaLockToggle.addEventListener("mousemove", (e) => {
                    tooltip.style.left = `${e.clientX + 12}px`;
                    tooltip.style.top = `${e.clientY + 12}px`;
                });
                alphaLockToggle.addEventListener("mouseleave", () => {
                    tooltip.style.display = "none";
                });

                alphaLockToggle.addEventListener("click", () => {
                    if (actualIndex === 0) return; // Disable toggle on background
                    layer.alphaLock = !layer.alphaLock;
                    alphaLockToggle.src = layer.alphaLock ? "lock.png" : "unlock.png";
                    if (actualIndex === 0) {
                        alphaLockToggle.style.opacity = 0.3;
                        alphaLockToggle.style.cursor = "not-allowed";
                        alphaLockToggle.title = "Alpha Lock disabled on background layer";
                    } else {
                        alphaLockToggle.title = "Toggle Alpha Lock";
                    }

                });






                // üìù Layer label (renameable)
                const labelWrapper = document.createElement('div');
                labelWrapper.classList.add('layer-label');
                labelWrapper.textContent = layer.name;
                labelWrapper.title = "Double click to rename";

                // prettier up/down arrows
                const arrowWrapper = document.createElement("div");


                arrowWrapper.className = "layer-arrows";

                const upBtn = document.createElement("button");
                const downBtn = document.createElement("button");


                upBtn.textContent = "‚¨ÜÔ∏è";
                downBtn.textContent = "‚¨áÔ∏è";

                upBtn.title = "Move layer up";
                downBtn.title = "Move layer down";

                if (actualIndex === 0) {
                    upBtn.disabled = true;
                    downBtn.disabled = true;
                    upBtn.style.opacity = 0.3;
                    downBtn.style.opacity = 0.3;
                    upBtn.style.cursor = "not-allowed";
                    downBtn.style.cursor = "not-allowed";
                }

                upBtn.addEventListener("click", (e) => {
                    e.stopPropagation();
                    moveLayer(actualIndex, actualIndex + 1);
                });

                downBtn.addEventListener("click", (e) => {
                    e.stopPropagation();
                    moveLayer(actualIndex, actualIndex - 1);
                });



                arrowWrapper.appendChild(upBtn);
                arrowWrapper.appendChild(downBtn);


                labelWrapper.style.cursor = 'text';
                labelWrapper.style.flexGrow = '0';
                labelWrapper.style.width = 'fit-content';
                labelWrapper.style.whiteSpace = 'nowrap';
                labelWrapper.style.overflow = 'hidden';
                labelWrapper.style.textOverflow = 'ellipsis';
                labelWrapper.style.maxWidth = '100px';

                labelWrapper.addEventListener('dblclick', (e) => {
                    e.preventDefault();
                    e.stopPropagation();

                    const input = document.createElement('input');
                    input.type = 'text';
                    input.value = layer.name;
                    input.style.width = '100%';
                    input.style.boxSizing = 'border-box';
                    input.style.fontSize = 'inherit';
                    input.style.border = '1px solid #ccc';
                    input.style.borderRadius = '4px';
                    input.style.padding = '2px 4px';

                    labelWrapper.replaceChildren(input);
                    input.focus();

                    function commitRename() {
                        const newName = input.value.trim();
                        if (newName) {
                            layer.name = newName;
                        }
                        updateLayerMenu();
                    }

                    input.addEventListener('blur', commitRename);
                    input.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter') input.blur();
                        if (e.key === 'Escape') updateLayerMenu();
                    });
                });


                // üñ±Ô∏è Clicking anywhere on the row (except checkbox) sets it active
                let clickTimeout = null;

                layerDiv.addEventListener('click', (e) => {
                    // Ignore clicks on interactive controls
                    const isControl = e.target.closest("button") || e.target.closest("span") || e.target.closest("img");
                    if (isControl) return;

                    if (clickTimeout) {
                        clearTimeout(clickTimeout);
                        clickTimeout = null;
                        return;
                    }

                    clickTimeout = setTimeout(() => {
                        setActiveLayer(actualIndex);
                        clickTimeout = null;
                    }, 250);
                });



                // ‚úÖ Assemble UI
                layerDiv.appendChild(thumb);
                layerDiv.appendChild(toggleWrapper);
                layerDiv.appendChild(labelWrapper);
                layerDiv.appendChild(arrowWrapper);


                layerContent.appendChild(layerDiv);
            });

            updateLayerThumbnails();
        }


        opacitySlider.addEventListener("input", () => {
            if (activeLayerIndex === 0) return;
            const val = parseFloat(opacitySlider.value);
            layers[activeLayerIndex].opacity = val;
            opacityValue.textContent = Math.round(val * 100) + "%";
            renderAllLayers();
        });



        function updateLayerThumbnails() {
            const thumbnails = document.querySelectorAll(".layer-item canvas");

            [...layers].reverse().forEach((layer, visualIndex) => {
                const thumb = thumbnails[visualIndex];
                const ctx = thumb.getContext("2d");
                ctx.imageSmoothingEnabled = false;
                ctx.clearRect(0, 0, thumb.width, thumb.height);
                ctx.drawImage(layer.canvas, 0, 0, thumb.width, thumb.height);
            });
        }




        // Draw something on the background layer (optional)
        layers[0].ctx.fillStyle = "#FFFFFF";
        layers[0].ctx.fillRect(0, 0, layers[0].canvas.width, layers[0].canvas.height);







        let isDrawing = false;
        let mouseDown = false;
        let lastX = 0;
        let lastY = 0;
        let brushSize = 2;
        let brushColor = "#000000";
        let isEraser = false;
        let hasDrawn = false;
        let isEyedropper = false;
        let isBucket = false;
        // Default to drawing layer

        function fillCanvasWhite() {
            ctx.fillStyle = "#FFFFFF";
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }
        function renderAllLayers() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // üëá Draw from bottom layer to top ‚Äî assuming layer[0] is bottom
            for (let i = 0; i < layers.length; i++) {
                if (layers[i].visible) {
                    ctx.globalAlpha = layers[i].opacity;  // üëà USE LAYER OPACITY
                    ctx.drawImage(layers[i].canvas, 0, 0);
                }
            }
            ctx.globalAlpha = 1; // üëà RESET after all layers drawn
        }






        function saveDrawingState() {
            const layer = layers[activeLayerIndex];
            const imgData = layer.ctx.getImageData(0, 0, canvas.width, canvas.height);
            layer.undoStack.push(imgData);
            // Clear redo stack when new state is added
            layer.redoStack = [];
        }




        function startDrawing(x, y) {
            isDrawing = true;
            mouseDown = true;
            hasDrawn = false;
            [lastX, lastY] = [x, y];

            if (isEyedropper) {
                handleToolClick(Math.floor(x), Math.floor(y));
            } else if (isBucket) {
                const layer = layers[activeLayerIndex];
                const currentState = layer.ctx.getImageData(0, 0, canvas.width, canvas.height);
                layer.undoStack.push(currentState);
                layer.redoStack = [];
                handleToolClick(Math.floor(x), Math.floor(y));
            } else {
                // For regular drawing/erasing, save state at the beginning
                const layer = layers[activeLayerIndex];
                const currentState = layer.ctx.getImageData(0, 0, canvas.width, canvas.height);
                layer.undoStack.push(currentState);
                layer.redoStack = [];
            }
        }

        function draw(x, y) {
            if (isEyedropper || isBucket || !isDrawing) return;

            hasDrawn = true;

            const layer = layers[activeLayerIndex];
            const layerCtx = layer.ctx;

            if (layer.alphaLock) {
                const strokeCanvas = document.createElement("canvas");
                strokeCanvas.width = canvas.width;
                strokeCanvas.height = canvas.height;
                const strokeCtx = strokeCanvas.getContext("2d");

                // Draw the stroke onto the stroke canvas
                strokeCtx.imageSmoothingEnabled = false;
                strokeCtx.lineCap = "round";
                strokeCtx.lineJoin = "round";
                strokeCtx.lineWidth = brushSize;
                strokeCtx.strokeStyle = isEraser ? "rgba(0,0,0,1)" : brushColor;
                strokeCtx.beginPath();
                strokeCtx.moveTo(lastX, lastY);
                strokeCtx.lineTo(x, y);
                strokeCtx.stroke();

                // Get image data from stroke and layer
                const strokeData = strokeCtx.getImageData(0, 0, canvas.width, canvas.height);
                const baseData = layer.ctx.getImageData(0, 0, canvas.width, canvas.height);

                const sData = strokeData.data;
                const bData = baseData.data;

                for (let i = 0; i < sData.length; i += 4) {
                    const baseAlpha = bData[i + 3];

                    if (baseAlpha === 0) {
                        // Prevent anything from appearing outside visible areas
                        sData[i + 3] = 0;
                    } else if (isEraser && sData[i + 3] > 0) {
                        // ‚ö°Ô∏è Eraser: make that pixel fully transparent in the BASE layer
                        bData[i + 0] = 0;
                        bData[i + 1] = 0;
                        bData[i + 2] = 0;
                        bData[i + 3] = 0;
                    }
                }


                if (isEraser) {
                    layer.ctx.putImageData(baseData, 0, 0);
                } else {
                    strokeCtx.putImageData(strokeData, 0, 0);
                    layer.ctx.globalCompositeOperation = "source-over";
                    layer.ctx.drawImage(strokeCanvas, 0, 0);
                }


                [lastX, lastY] = [x, y];
                renderAllLayers();
                updateLayerThumbnails();
                return;
            }



            // Regular drawing (no alpha lock)
            layerCtx.beginPath();
            layerCtx.moveTo(lastX, lastY);
            layerCtx.lineTo(x, y);
            layerCtx.lineWidth = brushSize;
            layerCtx.lineCap = "round";

            if (isEraser) {
                layerCtx.globalCompositeOperation = activeLayerIndex === 0 ? "source-over" : "destination-out";
                layerCtx.strokeStyle = activeLayerIndex === 0 ? "#FFFFFF" : "rgba(0,0,0,1)";
            } else {
                layerCtx.globalCompositeOperation = "source-over";
                layerCtx.strokeStyle = brushColor;
            }

            layerCtx.stroke();

            [lastX, lastY] = [x, y];
            renderAllLayers();
            updateLayerThumbnails();
        }



        function stopDrawing() {


            isDrawing = false;
            mouseDown = false;
        }


        function floodFill(x, y, targetHex, fillHex) {
            const fillRGB = hexToRgb(fillHex);
            const layerCtx = layers[activeLayerIndex].ctx;
            const imageData = layerCtx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            const width = canvas.width;
            const height = canvas.height;

            const visited = new Uint8Array(width * height);
            const queue = [[x, y]];

            const startIndex = (y * width + x) * 4;
            const targetRGB = [
                data[startIndex],
                data[startIndex + 1],
                data[startIndex + 2],
                data[startIndex + 3]
            ];

            // Skip only if the pixel matches EXACTLY the fill color including alpha
            if (
                targetRGB[0] === fillRGB[0] &&
                targetRGB[1] === fillRGB[1] &&
                targetRGB[2] === fillRGB[2] &&
                targetRGB[3] === 255
            ) return;

            function colorAt(x, y) {
                const i = (y * width + x) * 4;
                return [data[i], data[i + 1], data[i + 2], data[i + 3]];
            }

            function setColor(x, y) {
                const i = (y * width + x) * 4;
                data[i] = fillRGB[0];
                data[i + 1] = fillRGB[1];
                data[i + 2] = fillRGB[2];
                data[i + 3] = 255;
            }

            function matchColor(c1, c2, alphaLockCheck) {
                const [r1, g1, b1, a1] = c1;
                const [r2, g2, b2, a2] = c2;

                if (alphaLockCheck && a1 === 0) return false; // skip fully transparent pixels if alpha lock
                return (
                    Math.abs(r1 - r2) < 5 &&
                    Math.abs(g1 - g2) < 5 &&
                    Math.abs(b1 - b2) < 5 &&
                    Math.abs(a1 - a2) < 5
                );
            }


            while (queue.length > 0) {
                const [cx, cy] = queue.shift();
                if (cx < 0 || cy < 0 || cx >= width || cy >= height) continue;

                const idx = cy * width + cx;
                if (visited[idx]) continue;

                const current = colorAt(cx, cy);
                if (!matchColor(current, targetRGB, layers[activeLayerIndex].alphaLock)) continue;


                setColor(cx, cy);
                visited[idx] = 1;

                queue.push([cx + 1, cy]);
                queue.push([cx - 1, cy]);
                queue.push([cx, cy + 1]);
                queue.push([cx, cy - 1]);
            }

            layerCtx.putImageData(imageData, 0, 0);
            renderAllLayers();
            updateLayerThumbnails();  // ‚úÖ Live update after filling
        }




        function hexToRgb(hex) {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return [r, g, b];
        }

        function rgbToHex(r, g, b) {
            return (
                "#" +
                [r, g, b]
                    .map((x) => {
                        const hex = x.toString(16);
                        return hex.length === 1 ? "0" + hex : hex;
                    })
                    .join("")
                    .toUpperCase()
            );
        }

        function handleToolClick(x, y) {
            if (isEyedropper) {
                // Create a temporary canvas to composite visible layers
                const tempCanvas = document.createElement("canvas");
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                const tempCtx = tempCanvas.getContext("2d");

                // Composite all visible layers from bottom to top
                for (let i = 0; i < layers.length; i++) {
                    if (layers[i].visible) {
                        tempCtx.drawImage(layers[i].canvas, 0, 0);
                    }
                }

                // Sample pixel from merged result
                const pixel = tempCtx.getImageData(x, y, 1, 1).data;
                const hex = rgbToHex(pixel[0], pixel[1], pixel[2]);

                brushColor = hex;
                colorPicker.value = hex;
                updateLayerThumbnails();  // Optional

                return; // üëà THIS is the key fix!
            }

            if (!contiguousToggle.checked) {
                // Non-contiguous: fill entire canvas with brush color, including transparent areas
                const layer = layers[activeLayerIndex];
                const layerCtx = layer.ctx;

                // Save current state for undo
                const prevState = layerCtx.getImageData(0, 0, canvas.width, canvas.height);
                layer.undoStack.push(prevState);
                layer.redoStack = [];

                // Fill pixels in the image data
                const imgData = layerCtx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imgData.data;
                const rgb = hexToRgb(brushColor);

                for (let i = 0; i < data.length; i += 4) {
                    if (layer.alphaLock && data[i + 3] === 0) continue; // Skip fully transparent pixels if alpha lock
                    data[i] = rgb[0];
                    data[i + 1] = rgb[1];
                    data[i + 2] = rgb[2];
                    data[i + 3] = 255;
                }


                // Apply modified image data to the current layer
                layerCtx.putImageData(imgData, 0, 0);

                renderAllLayers();
                updateLayerThumbnails();
            }
            else {
                const layerCtx = layers[activeLayerIndex].ctx;
                const pixel = layerCtx.getImageData(x, y, 1, 1).data;
                const targetHex = rgbToHex(pixel[0], pixel[1], pixel[2]);

                floodFill(x, y, targetHex, brushColor);
            }

        }



        canvas.addEventListener("touchstart", (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touchX = e.touches[0].clientX - rect.left;
            const touchY = e.touches[0].clientY - rect.top;
            startDrawing(touchX, touchY);
        });

        canvas.addEventListener("touchmove", (e) => {
            e.preventDefault();
            const rect = canvas.getBoundingClientRect();
            const touchX = e.touches[0].clientX - rect.left;
            const touchY = e.touches[0].clientY - rect.top;
            draw(touchX, touchY);
        });

        canvas.addEventListener("touchend", stopDrawing);
        canvas.addEventListener("mousedown", (e) => startDrawing(e.offsetX, e.offsetY));
        canvas.addEventListener("mousemove", (e) => draw(e.offsetX, e.offsetY));
        canvas.addEventListener("mouseup", stopDrawing);
        document.addEventListener("mouseup", stopDrawing);

        brushSizeInput.addEventListener("input", (e) => {
            brushSize = e.target.value;
            sizeLabel.textContent = brushSize;
        });

        colorPicker.addEventListener("input", (e) => {
            brushColor = e.target.value;
        });

        eraserIcon.addEventListener("click", () => {
            isEraser = true;
            isEyedropper = false;
            isBucket = false;
            highlightTool("eraser");
        });

        brushIcon.addEventListener("click", () => {
            isEraser = false;
            isEyedropper = false;
            isBucket = false;
            highlightTool("brush");
        });

        eyedropperIcon.addEventListener("click", () => {
            isEyedropper = true;
            isEraser = false;
            isBucket = false;
            highlightTool("eyedropper");
        });

        bucketIcon.addEventListener("click", () => {
            isBucket = true;
            isEraser = false;
            isEyedropper = false;
            highlightTool("bucket");
        });

        function highlightTool(tool) {
            brushIcon.style.border = tool === "brush" ? "2px solid black" : "none";
            eraserIcon.style.border = tool === "eraser" ? "2px solid black" : "none";
            eyedropperIcon.style.border = tool === "eyedropper" ? "2px solid black" : "none";
            bucketIcon.style.border = tool === "bucket" ? "2px solid black" : "none";
        }

        undoButton.addEventListener("click", () => {
            const layer = layers[activeLayerIndex];
            if (layer.undoStack.length > 0) {
                const currentState = layer.ctx.getImageData(0, 0, canvas.width, canvas.height);
                layer.redoStack.push(currentState);

                const prevState = layer.undoStack.pop();
                layer.ctx.putImageData(prevState, 0, 0);
                renderAllLayers();
                updateLayerThumbnails();
            }
        });



        redoButton.addEventListener("click", () => {
            const layer = layers[activeLayerIndex];
            if (layer.redoStack.length > 0) {
                const currentState = layer.ctx.getImageData(0, 0, canvas.width, canvas.height);
                layer.undoStack.push(currentState);

                const redoState = layer.redoStack.pop();
                layer.ctx.putImageData(redoState, 0, 0);
                renderAllLayers();
                updateLayerThumbnails();
            }
        });


        submitButton.addEventListener("click", () => {
            const backgroundHidden = !layers[0].visible;
            const hasHiddenLayers = layers.some((layer, i) => i !== 0 && !layer.visible);

            if (backgroundHidden) {
                alert("üö´ The background layer must be visible to submit your drawing.");
                return;
            }

            if (hasHiddenLayers) {
                const proceed = confirm("‚ö†Ô∏è Warning! Hidden layers will not be submitted.\n\nDo you want to continue?");
                if (!proceed) return;
            }

            const imageData = canvas.toDataURL("image/png");



            fetch(imageData)
                .then(res => res.blob())
                .then(blob => {
                    const formData = new FormData();
                    formData.append("file", blob, "doodle.png");

                    fetch("https://discord.com/api/webhooks/1359909431868915953/WrhoQ4ZpZU0JG-Fvh197BuekJdXC56OYJbBHclhYiuvGqu0fhoKJ-6bjb3nwRoqxw7NM", {
                        method: "POST",
                        body: formData
                    })
                        .then(response => {
                            if (response.ok) {
                                alert("Submitted!");
                                ctx.clearRect(0, 0, canvas.width, canvas.height);
                                fillCanvasWhite();
                                saveDrawingState();
                            } else {
                                alert("Submission failed.");
                                console.error("Error:", response.statusText);
                            }
                        })

                        .catch(error => {
                            alert("Submission failed.");
                            console.error("Fetch error:", error);
                        });
                });
        });

        window.onload = () => {
            fillCanvasWhite();
            saveDrawingState();
            renderAllLayers();
        };
        document.addEventListener("keydown", (e) => {
            if (e.ctrlKey && !e.shiftKey && e.key === "z") {
                e.preventDefault();
                undoButton.click();
            } else if (e.ctrlKey && e.shiftKey && e.key === "Z") {
                e.preventDefault();
                redoButton.click();
            }
        });
        toggleLayerMenu.addEventListener("click", () => {
            const isVisible = layerMenu.style.display === "block";
            layerMenu.style.display = isVisible ? "none" : "block";
        });

        document.getElementById("downloadBtn").addEventListener("click", () => {
            const backgroundHidden = !layers[0].visible;
            const hasHiddenLayers = layers.some((layer, i) => i !== 0 && !layer.visible);

            if (backgroundHidden) {
                alert("üö´ The background layer must be visible to download your doodle.");
                return;
            }

            if (hasHiddenLayers) {
                const proceed = confirm("‚ö†Ô∏è Warning! Hidden layers will not be included in the downloaded image.\n\nDo you want to continue?");
                if (!proceed) return;
            }

            const link = document.createElement("a");
            link.download = "my-doodle.png";
            link.href = canvas.toDataURL("image/png");
            link.click();
        });



    </script>
</body>
</html>